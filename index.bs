<pre class="metadata">
Title: Writing Promise-Using Specifications
Group: W3C TAG
Shortname: promises-guide
Status: FINDING
Editor: Domenic Denicola, Google https://www.google.com/, https://domenic.me/, d@domenic.me
Abstract: This document gives guidance on how to write specifications that create, accept, or manipulate promises.
Default Biblio Status: current
!Participate: <a href="https://github.com/w3ctag/promises-guide">GitHub w3ctag/promises-guide</a> (<a href="https://github.com/w3ctag/promises-guide/issues/new">file an issue</a>; <a href="https://github.com/w3ctag/promises-guide/issues?state=open">open issues</a>)

Ignored Vars: O, f, args, x, cb
</pre>

<pre class="link-defaults">
spec:infra; type:dfn; text:list
spec:webidl; type:dfn; text:resolve
</pre>

<pre class="anchors">
urlPrefix: https://tc39.github.io/ecma262/; spec: ECMASCRIPT
    text: PerformPromiseThen; url: #sec-performpromisethen; type: abstract-op
    text: all(); for: Promise; url: #sec-promise.all; type: method
</pre>

<h2 id="intro">Introduction</h2>

A <em>promise</em> is an object that represents the eventual result of a single asynchronous operation. They can be returned from asynchronous functions, thus allowing consumers to not only queue up callbacks to be called when the operation succeeds or fails, but also to manipulate the returned promise object, opening up a variety of possibilities.

Promises have been battle-tested in many JavaScript libraries, including as part of popular frameworks like Dojo, jQuery, YUI, Ember, Angular, WinJS, Q, and others. This culminated in the <a href="https://promisesaplus.com/">Promises/A+ community specification</a> which most libraries conformed to. Now, a standard <code>Promise</code> class is included <a href="https://tc39.github.io/ecma262/#sec-promise-objects">in the ECMAScript Language Specification</a> [[!ECMASCRIPT]], allowing web platform APIs to return promises for their asynchronous operations.

Promises are now the web platform's paradigm for all "one and done" asynchronous operations. Previously, specifications used a variety of mismatched mechanisms for such operations. Going forward, all asynchronous operations of this type should be specified to instead return promises, giving our platform a unified primitive for asynchronicity.

<div class="note">Although the primary audience of this document is specification writers, it is also useful for JavaScript developers who want to write libraries or applications using promises. We will call out sections that are spec-writer specific so developers can skip them more easily.</div>


<h2 id="when-to-use">When to Use Promises</h2>

<h3 id="one-and-done">One-and-Done Operations</h3>

The primary use case for promises is returning them from a method that kicks off a single asynchronous operation. One should think of promise-returning functions as asynchronous functions, in contrast to normal synchronous functions; there is a very strong analogy here, and keeping it in mind makes such functions easier to write and reason about.

For example, normal synchronous functions can either return a value or throw an exception. Asynchronous functions will, analogously, return a promise, which can either be fulfilled with a value, or rejected with a reason. Just like a synchronous function that returns "nothing" (i.e. <code>undefined</code>), promises returned by asynchronous functions can be fulfilled with nothing (<code>undefined</code>); in this case the promise fulfillment simply signals completion of the asynchronous operation.

Examples of such asynchronous operations abound throughout web specifications:

- Asynchronous I/O operations: methods to read or write from a storage API could return a promise.
- Asynchronous network operations: methods to send or receive data over the network could return a promise.
- Long-running computations: methods that take a while to compute something could do the work on another thread, returning a promise for the result.
- User interface prompts: methods that ask the user for an answer could return a promise.

Previously, web specifications used a large variety of differing patterns for asynchronous operations. We've documented these in an appendix below, so you can get an idea of what is now considered legacy. Now that we have promises as a platform primitive, such approaches are no longer necessary.

<h3 id="one-time-events">One-Time "Events"</h3>

Because promises can be subscribed to even after they've already been fulfilled or rejected, they can be very useful for a certain class of "event." When something only happens once, and authors often want to observe the status of it after it's already occurred, providing a promise that becomes fulfilled when that eventuality comes to pass gives a very convenient API.

The prototypical example of such an "event" is a loaded indicator: a resource such as an image, font, or even document, could provide a <code>loaded</code> property that is a promise that becomes fulfilled only when the resource has fully loaded (or becomes rejected if there's an error loading the resource). Then, authors can always queue up actions to be executed once the resource is ready by doing <code>resource.loaded.then(onLoaded, onFailure)</code>. This will work even if the resource was loaded already, queueing a microtask to execute <code>onLoaded</code>. This is in contrast to an event model, where if the author is not subscribed at the time the event fires, that information is lost.

<h3 id="state-transitions">More General State Transitions</h3>

In certain cases, promises can be useful as a general mechanism for signaling state transitions. This usage is subtle, but can provide a very nice API for consumers when done correctly.

One can think of this pattern as a generalization of the one-time "events" use case. For example, take <code>&lt;img&gt;</code> elements. By resetting their <code>src</code> property, they can be re-loaded; that is, they can transition back from a loaded state to an unloaded state. Thus becoming loaded is not a one-time occasion: instead, the image actually consists of a state machine that moves back and forth between loaded and unloaded states. In such a scenario, it is still useful to give images a promise-returning <code>loaded</code> property, which will signal the next state transition to a loaded state (or be already fulfilled if the image is already in a loaded state). This property should return the same promise every time it is retrieved, until the image moves backward from the loaded state into the unloaded state. Once that occurs, a new promise is created, representing the <em>next</em> transition to loaded.

There are many places in the platform where this can be useful, not only for resources which can transition to loaded, but e.g. for animations that can transition to finished, or expensive resources that can transition to disposed, or caches that can become unloaded.

A slight variant of this pattern occurs when your class contains a method that causes a state transition, and you want to indicate when that state transition completes. In that case you can return a promise from the method, instead of keeping it as a property on your object. The <a href="https://github.com/whatwg/streams/">streams API</a> uses this variant for its <code>wait()</code> and <code>close()</code> methods. In general, methods should be used for actions, and properties for informational state transitions.

To close, we must caution against over-using this pattern. Not every state transition needs a corresponding promise-property. Indicators that it might be useful include:

- Authors are almost always interested in the <em>next</em> instance of that state transition, and rarely need recurring notification every time it occurs. For example, rarely do authors care to know every time an image element is reloaded; usually they simply care about the initial load of the image, or possibly the next one that occurs after resetting its <code>src</code>.
- Authors are often interested in reacting to transitions that have already occurred. For example, authors often want to run some code once an image is loaded; if the image is already loaded, they want to run the code as soon as possible.

<h2 id="when-not-to-use">When Not to Use Promises</h2>

Although promises are widely applicable to asynchronous operations of many sorts, there are still situations where they are not appropriate, even for asynchronicity.

<h3 id="recurring-events">Recurring Events</h3>

Any event that can occur more than once is not a good candidate for the "one and done" model of promises. There is no single asynchronous operation for the promise to represent, but instead a series of events. Conventional <code>EventTarget</code> usage is just fine here.

<h3 id="streaming-data">Streaming Data</h3>

If the amount of data involved is potentially large, and could be produced incrementally, promises are probably not the right solution. Instead, you'll want to use the under-development <a href="https://github.com/whatwg/streams">streams API</a>, which allows authors to process and compose data streams incrementally, without buffering the entire contents of the stream into memory.

Note that in some cases, you could provide a promise API alongside a streaming API, as a convenience for those cases when buffering all the data into memory is not a concern. But this would be a supporting, not primary, role.

<h2 id="api-design-guidance">API Design Guidance</h2>

There are a few subtle aspects of using or accepting promises in your API. Here we attempt to address commonly-encountered questions and situations.

<h3 id="errors">Errors</h3>

<h4 id="always-return-promises">Promise-Returning Functions Should Always Return Promises</h4>

Promise-returning functions should always return a promise, under all circumstances. Even if the result is available synchronously, or the inputs can be detected as invalid synchronously, this information needs to be communicated through a uniform channel so that a developer can be sure that by doing

<pre><code class="lang-javascript">
promiseFunction()
  .then(onSuccess)
  .catch(onFailure);
</code></pre>

they are handling all successes and all errors.

In particular, promise-returning functions should never synchronously throw errors, since that would force duplicate error-handling logic on the consumer: once in a <code>catch (e) { ... }</code> block, and once in a <code>.catch(e => { ... })</code> block. Even argument validation errors are not OK. Instead, all errors should be signaled by returning rejected promises.

For Web IDL-based specs, this is taken care of automatically <a href="https://heycam.github.io/webidl/#es-operations">by the Web IDL specification</a>: any exceptions thrown by Web IDL operations, or by the Web IDL overload resolution algorithm itself, are automatically converted into rejections.

<h4 id="reasons-should-be-errors">Rejection Reasons Should Be <code>Error</code>s</h4>

Promise rejection reasons should always be instances of the ECMAScript <code>Error</code> type, just like synchronously-thrown exceptions should always be instances of <code>Error</code> as well.

In particular, for DOM or other web platform specs, this means you should never use <code>DOMError</code>, but instead use <code>DOMException</code>, which <a href="https://heycam.github.io/webidl/#es-exceptions">per Web IDL</a> extends <code>Error</code>. You can of course also use one of the <a href="https://tc39.github.io/ecma262/#sec-error-objects">built-in ECMAScript error types</a>.

<h4 id="rejections-should-be-exceptional">Rejections Should Be Used for Exceptional Situations</h4>

What exactly you consider "exceptional" is up for debate, as always. But, you should always ask, before rejecting a promise: if this function was synchronous, would I expect a thrown exception under this circumstance? Or perhaps a failure value (like <code>null</code>, <code>false</code>, or <code>undefined</code>)? You should think about which behavior is more useful for consumers of your API. If you're not sure, pretend your API is synchronous and then think if your developers would expect a thrown exception.

Good cases for rejections include:

- A failed I/O operation, like writing to storage or reading from the network.
- When it will be impossible to complete the requested task: for example if the operation is <code>accessUsersContacts()</code> and the user denies permission, then it should return a rejected promise.
- Any situation where something is internally broken while attempting an asynchronous operation: for example if the developer passes in invalid data, or the environment is in an invalid state for this operation.

Bad uses of rejections include:

- When a value is asked for asynchronously and is not found: for example <code>asyncMap.get("key")</code> should return a promise for <code>undefined</code> when there is no entry for <code>"key"</code>, and similarly <code>asyncMap.has("key")</code> should return a promise for <code>false</code>. The absence of <code>"key"</code> would be unexceptional, and so a rejected promise would be a poor choice.
- When the operation is phrased as a question, and the answer is negative: for example if the operation is <code>hasPermissionToAccessUsersContacts()</code> and the user has denied permission, then it should return a promise fulfilled with <code>false</code>; it should not reject.

Cases where a judgement call will be necessary include:

- APIs that are more ambiguous about being a question versus a demand: for example <code>requestUsersContacts()</code> could return a promise fulfilled with <code>null</code> if the user denies permission, or it could return a promise rejected with an error stating that the user denied permission.

<h3 id="async-algorithms">Asynchronous Algorithms</h3>

<div class="note">This section is primarily for spec writers, dealing with the vagaries of clearly manifesting asynchronous algorithm flow in prose. For more background on this subject, see <a href="https://annevankesteren.nl/2014/08/asynchronicity">Anne's blog post on asynchronicity</a>.</div>

<h4 id="simply-resolve-or-reject">Simply Resolve or Reject the Promise</h4>

Unlike in the old world of callbacks, there's no need to create separate callback types (e.g. in Web IDL) for your success and error cases. Instead, just resolve or reject your promise.

<h4 id="explicit-async-steps">Note Parallel Steps Explicitly</h4>

It is important to note which steps in your algorithms will be run in parallel with the author's JavaScript code, i.e. without blocking script execution. This instructs implementers as to which operations will need to use e.g. a background thread or asychronous I/O calls. And it helps authors to know the expected sequencing of <em>their</em> operations with respect to those of your algorithm. To do this, use the phrase <a>in parallel</a> from [[!HTML]].

As an example, the following steps will give a promise that is resolved after <var>ms</var> milliseconds:

1. Let <var>p</var> be <a>a new promise</a>.
1. Run the following steps <a>in parallel</a>:
    1. Wait <var>ms</var> milliseconds.
    1. <a>Resolve</a> <var>p</var> with <b>undefined</b>.
1. Return <var>p</var>.

If we had omitted the "Run the following steps in parallel" heading, then the algorithm would have instructed implementers to block the main thread for <var>ms</var> milliseconds, which is very bad! Whereas as written, this algorithm correctly describes a non-blocking wait.

<h4 id="queue-tasks">Queue Tasks to Invoke Developer Code</h4>

Promises abstract away many of the details regarding notifying the developer about async operations. For example, you can say "<a>resolve</a> <var>p</var> with <var>x</var>" instead of e.g. "<a>queue a task</a> to call the callback <var>cb</var> with <var>x</var>," and it's understood that this will use the normal promise mechanisms. (Namely, the developer can wait for fulfillment or rejection by passing callbacks to the promise's <code>then</code> method, which will call those callbacks in the next microtask.) So in most cases, you will not need to explicitly queue tasks inside your promise-based asynchronous algorithms.

However, in cases where you need to interface with developer code in more ways than can be mediated via the promise, you'll still need to queue a task. For example, you may want to fire an event, which can call into developer event handlers. Or you may need to perform a structured clone operation, which <a href="http://lists.w3.org/Archives/Public/public-webcrypto/2014Mar/0141.html">can trigger getters</a>. If these things must be done inside the asynchronous portion of your algorithm, you need to specify that they are done via a queued task, and with a specific task queue. This nails down the exact time such developer-observable operations happen both in relation to other queued tasks, and to the microtask queue used by promises.

As an example, the following steps will return a promise resolved after <var>ms</var> milliseconds, but also fire an event named <code>timerfinished</code> on an object |object|:

1. Let <var>p</var> be <a>a new promise</a>.
1. Run the following steps <a>in parallel</a>:
    1. Wait <var>ms</var> milliseconds.
    1. <a>Resolve</a> <var>p</var> with <b>undefined</b>.
    1. <a>Queue a task</a> to <a href="https://html.spec.whatwg.org/multipage/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code>timerfinished</code> at the |object|.
1. Return <var>p</var>.

<h3 id="accepting-promises">Accepting Promises</h3>

<h4 id="resolve-arguments">Promise Arguments Should Be Resolved</h4>

In general, when an argument is expected to be a promise, you should also allow thenables and non-promise values by <em>resolving</em> the argument to a promise before using it. You should <em>never</em> do a type-detection on the incoming value, or overload between promises and other values, or put promises in a union type.

In Web IDL-using specs, this is automatically taken care of by the <a href="https://heycam.github.io/webidl/#es-promise">Web IDL promise type</a>. To see what it means in JavaScript, consider the following function, which adds a delay of <var>ms</var> milliseconds to a promise:

<div class="example">
    <pre><code class="lang-javascript">
    function addDelay(promise, ms) {
        return Promise.resolve(promise).then(v =>
            new Promise(resolve =>
                setTimeout(() => resolve(v), ms);
            )
        );
    }

    var p1 = addDelay(doAsyncOperation(), 500);
    var p2 = addDelay("value", 1000);
    </code></pre>
</div>

In this example, <code>p1</code> will be fulfilled 500 ms after the promise returned by <code>doAsyncOperation()</code> fulfills, with that operation's value. (Or <code>p1</code> will reject as soon as that promise rejects.) And, since we resolve the incoming argument to a promise, the function can also work when you pass it the string <code>"value"</code>: <code>p2</code> will be fulfilled with <code>"value"</code> after 1000 ms. In this way, we essentially treat it as an immediately-fulfilled promise for that value.

<h4 id="should-promise-call">Developer-Supplied Promise-Returning Functions Should Be "Promise-Called"</h4>

If the developer supplies you with a function that you expect to return a promise, you should also allow it to return a thenable or non-promise value, or even throw an exception, and treat all these cases as if they had returned an analogous promise. This should be done by converting the returned value to a promise, as if by using <code>Promise.resolve()</code>. The purpose of this is to allow us to have the same reaction to synchronous forms of success and failure that we would to asynchronous forms.

See the [[#webidl-developer-functions-returning-promises]] section for more on how this is done in Web IDL-using specifications.

<h2 id="webidl">Web IDL and Promises</h2>

<div class="note">This section is primarily for spec writers, dealing with how promises integrate with an interface definition language often used in web specs.</div>

[[!WEBIDL]] provides a <code><a interface>Promise</a>&lt;|T|&gt;</code> type which can be used when writing specifications that expose their API through Web IDL. Here we summarize how the <code><a interface>Promise</a>&lt;|T|&gt;</code> type relates to and enforces the guidelines in this document.

<p class="note" oldids="shorthand-phrases a-new-promise a-promise-resolved-with resolved-as-a-promise a-promise-rejected-with resolve-promise reject-promise upon-fulfillment upon-rejection transforming-by waiting-for-all waiting-for-all-promise promise-calling examples example-delay example-validated-delay example-add-delay example-resource-open example-environment-ready example-add-bookmark example-batch-request shorthand-note-on-realms webidl-examples">This document previously defined a number of terms for manipulating promises, and gave examples for using them, which have since moved to [[!WEBIDL]].</p>

<h3 id="webidl-promise-return-values"><code><a interface>Promise</a>&lt;|T|&gt;</code> Return Values</h3>

Like all Web IDL return values, declaring a return value of type <code><a interface>Promise</a>&lt;|T|&gt;</code> has no impact on the algorithm's actual return steps. It is simply a form of documentation, and if you return something that is not a promise or is a promise with a fulfillment value that is not of Web IDL-type <code>T</code>, then you have written incorrect documentation into your spec.

However, declaring that your method or accessor returns a promise does have one important impact: it ensures that any exceptions that it would otherwise throw, e.g. as a result of failed type conversions, are caught and turned into rejected promises. (See the <a href="https://heycam.github.io/webidl/#es-operations">"Operations" section</a>, "If <var ignore>op</var> has a return type that is a promise type …", and similar phrases scattered throughout the document.) This automatically takes care of the advice in [[#always-return-promises]], at least for exceptions.

<h3 id="webidl-promise-parameters"><code><a interface>Promise</a>&lt;|T|&gt;</code> Parameters</h3>

When a parameter of a Web IDL operation is declared as <code><a interface>Promise</a>&lt;|T|&gt;</code>, it will automatically resolve any arguments passed in that position. This will take care of the [[#resolve-arguments]] advice above.

If you have a <code><a interface>Promise</a>&lt;|T|&gt;</code> argument, you can use the Web IDL [=upon settling|perform some steps once a promise is settled=] algorithm, or the more targeted [=upon fulfillment=] and [=upon rejection=] algorithms, to unwrap the promise's value. This also handles type conversion to |T| (although, see <a href="https://github.com/heycam/webidl/issues/782">heycam/webidl#782</a>).

Note that the |T| here refers to a Web IDL type <em>for the fulfillment value</em>. Furthermore, it only has impact if you use the Web IDL "perform some steps …" algorithm, and not if you use the promise in other ways (such as passing it along to another function). If that is not relevant, we advise using <code>Promise&lt;any&gt;</code> for parameters.

<div class="note">
    As a consequence of the resolution behavior, <code><a interface>Promise</a>&lt;|T|&gt;</code> parameters cannot be overloaded with any other parameters. For example, you cannot do:

    <pre>
    // INVALID WEBIDL
    void f(Promise&lt;DOMString&gt; x);
    void f(DOMString y);
    </pre>
</div>

<h3 id="webidl-developer-functions-returning-promises" oldids="webidl-user-functions-returning-promises">Developer Functions Returning Promises</h3>

In Web IDL, you consume JavaScript functions by declaring them as [=callback functions=] (or, in rare cases, via [=callback interfaces=]) and later [=invoke|invoking=] them with a list of Web IDL values.

If you use these mechanisms, the invocation algorithm will automatically resolve return values and convert thrown exceptions into rejected promises. This automatically takes care of the advice in [[#should-promise-call]].

<h2 id="legacy" class="no-num">Appendix: Legacy APIs for Asynchronicity</h2>

Many web platform APIs were written before the advent of promises, and thus came up with their own ad-hoc ways of signaling asynchronous operation completion or failure. These include:

- IndexedDB returning <a href="http://www.w3.org/TR/IndexedDB/#request-api"><code>IDBRequest</code></a> objects, with their <code>onsuccess</code> and <code>onerror</code> events
- The File API's <a href="http://www.w3.org/TR/file-system-api/#methods"><code>methods</code></a> taking various <code>successCallback</code> and <code>errorCallback</code> parameters
- The Notifications API's <a href="https://notifications.spec.whatwg.org/#dom-notification-requestpermission"><code>requestPermission</code></a> method, which calls its callback with <code>"granted"</code> or <code>"denied"</code>
- The Fullscreen API's <a href="https://fullscreen.spec.whatwg.org/#dom-element-requestfullscreen"><code>requestFullscreen</code></a> method, which triggers <code>onfullscreenchange</code> or <code>onfullscreenerror</code> events on the nearby <code>document</code> object that must be listened to in order to detect success or failure
- XMLHttpRequest's <a href="https://xhr.spec.whatwg.org/#the-send%28%29-method"><code>send</code></a> method, which triggers <code>onreadystatechange</code> multiple times and updates properties of the object with status information which must be consulted in order to accurately detect success or failure of the ultimate state transition

If you find yourself doing something even remotely similar to these, stop, and instead use promises.
